require "active_support/core_ext/array"
require "active_support/concern"

module Susanin

  class Resource

    def initialize(values=[])
      @resources = values.dup
    end

    def url_parameters(record_or_hash_or_array, options={})
      params = self.get(Array.wrap(record_or_hash_or_array)).flatten
      opts, params = params.partition { |i| i.is_a?(Hash) }
      merged_options(params, opts.inject(options) { |acc, i| acc.merge(i) })
    end

    #
    # get(
    #   [:a, :c, :d],
    #   [
    #     [[:A, :B], ->(r) {:a}]
    #     [[:A], ->(r) {:q}]
    #     [[:C], ->(r) {:w}]
    #     [[:E], ->(r) {:e}]
    #   ]
    # )
    #
    # [:qwe, :wer, :d]
    #
    def get(record, resources=@resources)
      new_record, new_resources = replace_with(Array.wrap(record), resources)
      if record == new_record
        new_record
      else
        get(new_record, new_resources)
      end
    end

    #
    # replace_with(
    #   [:a, :b, :c, :d],
    #   [
    #     [[:A, :B], ->(r) {:a}]
    #     [[:C], ->(r) {:w}]
    #     [[:E], ->(r) {:e}]
    #   ]
    # )
    #
    #  [
    #   [:a, :c, :d],
    #   [
    #     [[:C], ->(r) {:w}]
    #     [[:E], ->(r) {:e}]
    #   ]
    #  ]
    #
    def replace_with(record, resources)
      record = record.dup
      resources = resources.dup
      pattern, converter = find_first_pattern(record, resources)

      [replace_subrecord(record, pattern, converter), resources_except(resources, pattern)]
    end

    #
    # find_first_pattern(
    #   [:a, :b, :c, :d],
    #   [
    #     [[:A, :B], ->(r) {:a}]
    #     [[:C], ->(r) {:w}]
    #     [[:E], ->(r) {:e}]
    #   ]
    # )
    #
    # [[:A, :B], ->(r) {:a}]
    #
    def find_first_pattern(record, resources)
      record_patterns = patterns(get_key(record))

      resources.select do |r|
        record_patterns.include?(r[0])
      end.first || []
    end

    #
    # resources_except(
    #   [
    #     [[:A, :B], ->(r) {:a}]
    #     [[:A], ->(r) {:q}]
    #     [[:C], ->(r) {:w}]
    #     [[:E], ->(r) {:e}]
    #   ],
    #   [:A, :B]
    # )
    #
    # [
    #   [[:C], ->(r) {:w}]
    #   [[:E], ->(r) {:e}]
    # ],
    #
    def resources_except(resources, keys)
      keys = Array.wrap(keys)
      new_resources = resources.dup
      new_resources.reject! { |r| contains_subarray?(keys, Array.wrap(r[0])) }
      new_resources
    end

    #
    # get_key(a) => A
    # get_key(A) => A
    # get_key([a]) => [A]
    # get_key([a, B]) => [A, B]
    # get_key([A]) => [A]
    # get_key([A]) => [A]
    # get_key(:qwe) => :qwe
    # get_key([:qwe]) => [:qwe]
    # get_key('qwe') => 'qwe'
    #
    def get_key(record)
      case record
        when Class then record
        when Array then record.map { |i| get_key(i) }
        when Symbol then record
        when String then record
        else record.class
      end
    end

    #
    # merged_options([], {}) #=> []
    # merged_options([a], {}) #=> [a]
    # merged_options([a, {}], {}) #=> [a]
    # merged_options([a, {a: 1}], {}) #=> [a, {a: 1}]
    # merged_options([a, {}], {a: 1}) #=> [a, {a: 1}]
    # merged_options([a, {a: 1}], {a: 2}) #=> [a, {a: 1}]
    #
    def merged_options(params, options={})
      params = params.dup
      default_options = params.extract_options!
      params + ((default_options.any? || options.any?) ? [default_options.merge(options)] : [])
    end

    #
    # contains_subarray?([1,2,3,4,5], [1,2,3]) => true
    # contains_subarray?([1,2,3,4,5], [3,4]) => true
    # contains_subarray?([1,2,3,4,5], [1,3,4]) => false
    # contains_subarray?([1,2,3,4,5], 5) => true
    #
    def contains_subarray?(source, subarray)
      source = Array.wrap(source)
      subarray = Array.wrap(subarray)
      iteration_count = source.length - subarray.length
      0.upto(iteration_count).any? do |i|
        source[i..(i+subarray.length-1)] == subarray
      end
    end

    def patterns(arr)
      Pattern.new(arr)
    end

    #
    # replace_subrecord(
    #   [:a, :b, :c, :a, :b, :b],
    #   [:a, :b],
    #   ->(){ '_1_' }
    # )
    #
    # ['_1_', :c, '_1_', :b]
    #
    def replace_subrecord(record, pattern, resource)
      record = record.dup
      pattern = Array.wrap(pattern)

      i = pattern.length

      return record if i == 0

      while i <= record.length do
        set = (0+(i-pattern.length))..(i-1)
        subset = record[set]

        if pattern_match?(subset, pattern)
          value = resource.call(*subset)
          record[set] = value
          i += Array.wrap(value).size
        else
          i += 1
        end
      end

      opts, r = record.partition { |i| i.is_a?(Hash) }
      opts.any? ? [*r, opts.inject({}, :merge)] : r
    end

    #
    # pattern_match?([a, b], [A, B]) => true
    # pattern_match?([a, b], [a, b]) => false
    #
    def pattern_match?(record, pattern)
      Array.wrap(get_key(record)).zip(Array.wrap(pattern)).all? do |a, b|
        b.is_a?(Class) && a.is_a?(Class) ? a <= b : b == a
      end
    end

    def array_unwrap(a)
      a.size == 1 ? a[0] : a
    end

  end

end
